来自jdon的讨论 (http://www.jdon.com/27452/10)：

本人是初学的，觉得软件发展到现在为什么要出现分层，最主要目的是在不同的层中观注不同的问题域，从而来提高软件的逻辑清晰度及
将相同性质的问题统一管理。分层会增加软件设计的复杂性，但是可以使软件的逻辑更加清晰，在软件的生命周期中更快速地找到设计的
缺陷。不同的层次所处理的问题域不同。跟据楼主的说法本人就将其分成三层

持久层(Dao：接口，定义了持久化方法，CRUD DaoImpl：Dao的实现)
数据层(Domain：提供getter/setter)
控制层(Service：业务逻辑)

楼主在dao中定义了getUserOrderByID() getAllUserOrder() insertUserOrder() updateUserOrder() delUserOrder()五个方法其中
getUserOrderByID() getAllUserOrder() 两方法是持久化的需要如果不能跟持久化扯上什么关系最好也把他定义到数据层,而后面的
<根据地区查询客户getUserByArea()，或者 根据产品线和地区查询客户 getUserByAreaSrv()>这应放到数据层中，他关注的问题只是
数据，而要实现他的业务逻辑还需其他的业务类来调用,为什么想到的是放到Service中，那为什么要提供Domain这个东东呢。
对于第二个问题，楼主这样子想，我还是觉得他把Domain忘记了，DAO如果只是用来持久化的，就不应来提供业务数据，
而应放在Domain中。
请注意分层是程序员在不同的层面关注的问题的，如果各层面关注的问题不能清楚的划分，那分层一点意义都没反而反会增加程序的
复杂性。楼主是将持久化跟数据层混到一起了，如果这样子不影响解决问题了也是可行的，技巧技术在小型系统中反而会使问题复杂化。

>  感觉service有点象facade啊
   Service是类的性质，Facade是组织类的方式，一个象小组成员；一个是小组管理方式，不一样。
   很多人都习惯使用Facade组织Service，其实这不是最好方案，目前适合的就是通过Ioc组织。


1.客服端请求响应层
2.服务层
3.数据持久层
上面三个层中业务层是相对稳定的，当然前提是再需求不变的情况。所以业务层应该包含了所有完成需求所需要的功能。
数据持久层是服务层引申出来的。服务层完成业务操作，需要持久化数据或取回已持久化的数据，所以会抛出持久化（数据访问）需求。数据持久层的职责就是满足服务层抛出的持久化（数据访问）需求。所以对于业务层来说，不关心持久策略是什么，只关心有没有满足它的持久需求。按照这样的思路来保证持久策略的可变性。
服务层＋数据持久层组成了的业务服务。访问服务是通过服务层访问。服务层会将全部服务功能发布出来。并且这个业务服务是可重用的。
用户要利用系统来完成业务，目前还缺少用户接口，这就需要客服端请求响应层。客服端请求响应层职责是接受并解析客户端请求，根据解析的结果使用服务，并将使用服务的结果响应给客户端请求。
－－－－－
dao中定义了getUserOrderByID() getAllUserOrder() insertUserOrder() updateUserOrder() delUserOrder()五个方法
－－－－－－
这五个方法都是由于服务层完成业务功能时的需求，所以数据访问层必须实现。如果业务操作中没有删除客户资料的业务，也就意味着不需要删除客服资料的业务功能，那么，就没有删除用户资料的持久操作需求，DAO中也就没有必要实现delUserOrder（）
－－－－－
现在需要一个 根据地区查询客户getUserByArea()，或者 根据产品线和地区查询客户 getUserByAreaSrv()
－－－－－－
这也是一个业务需求，所以对应系统的服务层也必须要求有相应的业务功能，也就会有相应的持久化需求，DAO也必须实现相应的持久操作。

服务层中抛出的持久需求，有很多是可以合并的，比方说上面根据地区或根据产品线查询客户，这两个就可以合并为一个综合查询的数据访问接口。


大家回答得挺好，从各个方面说明业务层Service必要性。

我想从DDD（Domain-Driven Design）观点来补充说明楼主这个层次得必要性。

按照DDD领域建模观点看，中间业务层还应该再分为应用层和领域层（具体文章见http://domaindrivendesign.org）。
楼主的Service属于应用层，Domain则属于领域层。

在DDD观点看来，领域模型Domain其实分为三种元素：实体Enity、值对象（Value Object）和服务（Service）。

模型对象分实体和值对象，其实就是实体对象和对象状态的区分，值对象表示对象状态，在我设计JiveJdon3中，有ForumState和ForumThreadState，其实它们就是值对象，对象状态非常重要，它和对象生命周期scope有密切关系，最近出了一个Scopes开源免费框架就是专门提供对象生命周期管理的，所以，作为一个业务层框架必须有提供生命周期管理功能。
状态对象：数据库的替代者

服务是一些行为功能，有人指出没有行为的模型只有getter/setter
,是不是贫血模型，或者叫失血模型，DDD专家Eric Evans认为：将领域需要的功能强加给实体和值对象，不仅会破坏模型中对象定义，而且会认为地添加毫无意义的对象，

失血模型的请教

service这一层的用途和用法迷惑了很久了，今日才得解开，感谢各位！
另外加一点本人的认识：
分层的基本出发点是技术环节解耦。

关于持久层的解耦，yang1981说得太清楚了，下面引用：“数据持久层是服务层引申出来的。服务层完成业务操作，需要持久化数据或取回已持久化的数据，所以会抛出持久化（数据访问）需求。数据持久层的职责就是满足服务层抛出的持久化（数据访问）需求。所以对于业务层来说，不关心持久策略是什么，只关心有没有满足它的持久需求。按照这样的思路来保证持久策略的可变性。”

另外谈一下本人对表现层解耦的认识：多年来软件变化最大、最快、最激烈的其实是表现层，从字符界面、图形桌面、Web，到现在的Ajax、RIA。过去以foxbase和VB、PB、Delphi为代表的应用系统，表现层和业务层是完全耦合的，当表现层变化之后，立即面临被淘汰的命运，这是惨痛的教训，绝不应重演。B/S大潮后的这几年，很多人把Web作为表现层的终点，所以RoR才会炒起来。但历史经验表明，Web绝不可能是终点。当下一个革命性的表现层成熟的时候，Web仍会退位。
真正可怜的是业务层，其实变化很小，而扩展无限。每次随表现层的变化推倒重来，既是程序员的恶梦，更是企业的恶梦。我们一定要将二者分开，不要再成天重写系统了。保护、扩展企业的业务逻辑，当是每一位程序员的天职。
