http://www.jdon.com/45318


使用依赖注入实现聚合根之间调用的逻辑悖论
2013-04-12 17:16

13
赞
标签 关联模型      领域事件      EventSourcing      DDD聚合
转自: 依赖注入与事件编程
DDD中如果有两个聚合根调用，如何解决？如果还是使用依赖注入，就会发生聚合根嵌套的可笑事情发生。

以代码为例子：有两个聚合根类AggregateRoot1 AggregateRoot2，AggregateRoot1的方法依赖AggregateRoot2实现，如果采取依赖注入，也就是Spring等框架做法如下：


class AggregateRoot1{
    AggregateRoot2 aggregateRoot2;

     public void dosth(){
       ....
        aggregateRoot2.dosth();
      ...
    }
}


2013-04-12 17:16 "@banq
"的内容
那么两个聚合根之间相互调用怎么办？
只有通过事件。 ...


正是基于聚合根之间只能使用异步事件或消息，可能导致数据不一致性，Evans才发表文章：在聚合根实现CAP定理 Acknowledging CAP at the Root -‐-‐ in the Domain Model。



AggregateRoot1的dosth方法依赖AggregateRoot2的dosth方法，不自觉就将AggregateRoot2使用依赖注入，但是这样就造成了AggregateRoot1聚合AggregateRoot2的现象，AggregateRoot2还是聚合根吗？

什么是聚合？


class A{
   private B b;
   public B getB(){
      return b;
    }
}


这段代码表达了A聚合了B，也就是说整体A包含了部分B，A和B关系是父与子，整体与部分的关系。

我们使用这种聚合关系表达A是B的父对象，对于DDD聚合，如果A不再被其他对象引用，类似二叉树的一个根节点，那么我们认为A就是聚合根。

但是，因为依赖注入，我们破坏了业务上的聚合根概念。

那么两个聚合根之间相互调用怎么办？
只有通过事件。


认为聚合根之间遵循CAP定律，实现最终一致性即可。以前的讨论贴：聚合与一致性和有界上下文，

聚合根存在于有界上下文，在上下文场景诞生并进行测试，如果两个聚合根通过直接引用，如上面roo1和roo2，则可能破坏它们各自所在上下文场景。

.聚合根之间通过ID关联即可，一个聚合根的任何一个操作不应该依赖于其他聚合根的信息或操作；
2.聚合根之间只能是最终一致性；
3.聚合根之间异步通信用event-driven architecture来实现；
4.saga，或ProcessManager就是用来实现这种异步通信从而实现最终一致性的一种技术；
5.采用event sourcing+in memory的架构模式让这一切更完美；

发现jdon上目前讨论saga或processmanager的帖子很少，但实际上要实现最终一致性，它们不得不提。

这个的前提是做分布式系统,两个聚合根被隔离了,当然只能用ID,这个根聚合根直接引用并没矛盾 ...


ID关联我是第一次听说，英文的identity 不一定是ID，而可能是一种表示标识的对象，如果直接用比如整数型ID，这个ID实际是一个值(值对象)。

在我们对象世界中，万物皆对象，如果一个字段想混入对象界，至少它带个值对象的头衔吧？

假设类似数据表外键这种ID可以使用，它和聚合根对象直接引用应该不矛盾。这两种在技术上尽管行得通，却违背领域语言，那么可能是一种crack黑客技术。

为什么我认为违背领域语言呢？聚合是显式，其背景隐式是bounded context，如同鱼和水的关系，两个聚合相当两个鱼缸，如果使用直接引用，相当于把两条鱼放在一个鱼缸中，水也合并在一起，bounded context混在一起就不是有界bounded了。

Evans还继续在这个PPT中论述，聚合是必须在bounded context中进行断言测试的，如果两个聚合直接引用，如何划定它们的测试用例呢？这是一种紧耦合带来的致命问题。

退一步讲，一个聚合包含另外一个聚合的ID值，那么这个聚合如果想调用另外一个聚合中的方法，还需要通过ID值将那个聚合代码加载到内存中，才能进行方法调用啊。注意方法调用才是关键，不能因为方法调用而将两个类耦合在一起。



延伸开来，经常有人提出一个误导问题：Java传递的值还是引用？
这个问题其实是应该在分析设计领域来回答，分析设计时，该使用值还是使用引用？除了值和引用之外难道没有另外一种实现关系的办法吗？No, 使用消息事件。作为底层语言都应该提供这三种方式实现。

这个问题实际应该属于Context maping上下文映射，通过服务这样一个无副作用的接口可以是实现不同上下文之间的翻译转换，事件和服务都属于一种契约合同DBC，事件同样也是和在不同上下文之间传递。

种问题最好避免，应当重构！重构思路如下：

0、一个bounded context之内，只能有一个root aggregate! 一山不容二虎！
1、真正的问题可能是两个bounded context之间如何协作？ 一般是异步messaging的方式。

出现这种问题的诱因可能是：不小心把uses-a的关系，表达为has-a的关系。

UML中的dependency和association可认为是uses-a的关系。（uses-a的关系强度：association > dependency）
aggregation和composition可认为是has-a的关系。（has-a的关系强度：composition > aggregation）

如果是has-a的关系，用依赖注入的方式无可厚非，挺适合的，与现实贴合。（值的依赖以及延迟绑定）
如果是uses-a的关系，通过异步消息，进行松耦合比较好，与现实更贴合。（行为逻辑的依赖以及延迟绑定）

但是has-a和uses-a中的“a”在编译期就可以确定的，而不是运行时确定，就不必劳烦IoC和Messaging了。
（个人观点，因为代码看起来可能更直白和紧凑些，易于理解）

关于bounded context（业务场景）之间的关系的设计思路：
1）彼此之间，尽量独立，老死不相往来；
2）动态行为逻辑的依赖，使用异步messaging的方式；
3）动态值或类型的依赖，使用IoC的方式；（比如根据运行时的上下文，为业务场景提供不同的数据来源）
4）编译期确定行为或值的，可使用直接作为场景内部的一个方法或字段。



写得很好，如果结合DDD领域模型，has-a的聚合和组合主要是在聚合根中使用；而uses-a主要是在服务Service中使用。

问题来了，大量使用依赖注入IOC却是在Service中，比如一个Service代码需要依赖DAO，代码如下：


public class AServiceIml implements AService{

      @Inject   //将aDao实例注入
      private ADao aDao;

     public void save(A a){
         aDao.save(a);
     }

}



如此一个原则性错误，误用依赖好像很多年，老外业界也没有什么质疑，难道是我们错了？

、数据源的读写
Dao， DaoImpl, Service, ServiceImpl，这种写法，时常是对interface的滥用，对IoC的滥用，大量接口的出现，并不意味着“针对接口编程”，甚至可能把本身应该couple的业务概念decouple掉，或反之。

不过Service和Dao的关系，我觉得应该是has-a的关系，Dao可以理解为Service内部的记忆机制。

已经不怎么用Dao了，更倾向于在需要存储的方法内部直接使用类似dbutils、spring jdbctemplate或自己写的对jdbc轻量级封装的库，易于书写SQL语句，直接读写数据源。

为什么使用同步或直接的方式呢？因为没有数据，业务场景一般是进行不下去的，一些纯写且不需要实时返回结果的场景，可以考虑用异步的方式，使用jdk并发包的Future、ExcutorService等类封装jdbc，比较容易实现。

2、服务之间、聚合根之间
如果S1与S2存在uses-a关系，两者之间的协作一般是用messaging的方式，这个我们已可以达成共识。

那么，S1中的老大聚合根A1, S2中的老大聚合根A2，它们之间怎么协作呢？服务已经界定了聚合根的权利边界了，它们之间的协作，也得通过服务之间的协作方式，即异步messaging的方式进行。


如果一个对象想通过事件去通知另一个对象做事情，那意味着这件要做的事情还没发生。那就不能用事件，而应该用command。我请求你做做什么，我就发一个request给你，或者command给你，然后你处理就行；所以，聚合根内，发出来的事件一定是告诉别人我发生了什么，而不能是请帮我做什么这样的事件；请帮我做什么实际上已经带有目的性，也就是说它实际上已经知道了谁会去处理该事情。如果这种情况你也用事件，虽然从技术角度来说勉强解耦了，但从语义上来说并没有解耦，也就是你说的逻辑上的依赖；聚合根之间的通信应该总是由一个第三方的对象来协调，如event handler。

所以，在国外，才会有saga的存在，或者叫ProcessManager的存在。这个就是实现聚合根的异步通信而设计的产物
感谢你的回复。
正如你提到的，没有必要将两个逻辑上具备依赖关系的聚合根使用event去“勉强解耦”。那么当我们发现当业务演化至一定程度导致我们不得不去做很多的“勉强解耦”时，我们应当去考虑重新进行系统的设计，重新去划分聚合根，而不是去纠结于“要不要去使用IOC"或者“是否使用event更好"。

ProductUpdatedEvent(productVO.getProductId))
是否应该是BacklogDoSthEvent更为合理，由product来消费这条消息。 ...


言之有理，这个代码我主要是强调聚合，顺便写个事件代码，严格改写如下：


public class BacklogItem{
      private ProductVO productVO;

      public void updateProduct(){
         //向Product聚合根发事件消息实现调用
       domainevents.send(new
                      ProductUpdatedEvent(productVO.getProductId));
      }
}



方法名称改为updateProduct，那么ProductUpdatedEvent确实是在这里发生了。

我的观点是：消息是信封，信封内的内容可以是发生的事件Event，也可以是命令Command. (如果你一定要区分事件和命令的话)

如果在这里引入“事件”概念可能就很清晰了，实体 值对象 、服务 和事件，四个要素，这样在领域层，为实体服务的函数就不叫领域服务，而称为领域事件，实体通过发出各种事件调度技术架构为其服务，而将领域服务真正落实为开放给应用层的接口。 ...


DDD创始人Eric Evans最近发表了一篇文章：
[PDF]在聚合根实现CAP定理 Acknowledging CAP at the Root -‐-‐ in the Domain Model

Eric Evans在文中阐述了聚合体内部 聚合体之间以及领域事件Domain event和有界上下文bounded context等概念。

CAP定理主要突出最终一致性，Eric Evans在这篇文章强调了聚合体内部必须保证高一致性，类似关系数据库更新那种，当然内存中聚合体可以采取线程锁等方式实现；而聚合体之间可以是一种弱一致性，也就是实现最终一致性，Eric还是使用了货运Cargo这个案例，在不同地方装卸时间不一样导致更新不一致。

如下图，聚合与一致性的关系：

Eric evans强调了聚合体之间只能通过聚合根进行引用，而不能对聚合体内部元素进行引用，这样保证聚合边界的清晰。

聚合的定义：正如我们之前在DDD案例:网上商店讨论一样，聚合表达的是一种逻辑上的紧密联系结构，注意，还有这些逻辑结构的更新，如果说关系数据表通过外键等关系也能表达逻辑上的紧密联系，那么聚合与关系数据的区别是有更新动作，当然，关系数据表的更新是通过SQL+记录锁来实现，而聚合的更新通过编程语言如Java的锁等机制保证。


领域事件domain event代表一种对领域层中状态进行改变的发生事件或动作。这个在DDD大型实现我们已经讨论，如果不引入领域事件，会发生楼主在领域中引入领域服务的尴尬之处。

有界的上下文是对模型进行断言验证的地方，能够进行断言的必然是函数接口，而领域服务肯定是一种无副作用的函数接口，实际上也就说明了，有界的上下文是对领域服务进行调用测试的客户端使用现场。

看来Evans对DDD的进一步解释和我们在Jdon讨论的方向基本一致，没有发生大的偏差。


哈哈，banq终于关注有界上下文了，我现在在改造我写的架构，因为我只需要部分EventSoucing，希望能达到既实现CQRS的功能，又能保持经典DDD的代码，有界上下文应该是一个很重要的切入点。

2013-01-25 10:49 "@banq"的内容

聚合的更新通过编程语言如Java的锁等机制保证。


在领域描述问题是任何技术上的用语都应该被隐藏起来，即使是那样实现的

聚合内的高度一致性，聚合体之间的最终一致性都是有界上下文来实现，绝对不仅仅是“调用测试的客户端使用现场”
